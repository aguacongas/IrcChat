@using IrcChat.Shared.Models
@using IrcChat.Client.Components
@using IrcChat.Client.Services
@inject IEmojiService EmojiService

<div class="input-area">
    <div class="input-wrapper">
        <input @ref="inputElement"
               @bind="messageInput"
               @bind:event="oninput"
               placeholder="Tapez votre message... (@@ pour mentionner, : pour emoji)"
               @onkeydown="HandleKeyDown"
               @onkeyup="HandleKeyUp"
               disabled="@(!IsConnected)" />
        
        @if (showAutoComplete && filteredUsers.Any())
        {
            <div class="autocomplete-dropdown">
                @foreach (var (user, index) in filteredUsers.Select((u, i) => (u, i)))
                {
                    <div class="autocomplete-item @(index == selectedUserIndex ? "selected" : string.Empty)"
                         @onclick="() => SelectUser(user.Username)"
                         @onmouseenter="() => selectedUserIndex = index">
                        <span class="autocomplete-username">@user.Username</span>
                    </div>
                }
            </div>
        }

        @if (showEmojiAutocomplete && filteredEmojis.Any())
        {
            <div class="autocomplete-dropdown emoji-autocomplete">
                @foreach (var (emoji, index) in filteredEmojis.Select((e, i) => (e, i)))
                {
                    <div class="autocomplete-item @(index == selectedEmojiIndex ? "selected" : string.Empty)"
                         @onclick="() => SelectEmojiFromAutocomplete(emoji)"
                         @onmouseenter="() => selectedEmojiIndex = index">
                        <span class="emoji-char">@emoji.Emoji</span>
                        <span class="emoji-code">@emoji.Code</span>
                    </div>
                }
            </div>
        }
    </div>

    <button @onclick="SendMessage" disabled="@(!IsConnected)">Envoyer</button>

    <button class="emoji-button" @onclick="ToggleEmojiPicker" title="InsÃ©rer un emoji" disabled="@(!IsConnected)">
        ðŸ˜€
    </button>    
</div>

<EmojiPicker @bind-IsOpen="isEmojiPickerOpen" OnEmojiSelected="InsertEmoji" />

@code {
    private string messageInput = string.Empty;
    private ElementReference inputElement;
    private bool showAutoComplete = false;
    private List<User> filteredUsers = [];
    private int selectedUserIndex = 0;
    private string currentMentionQuery = string.Empty;
    private int mentionStartPosition = 0;

    // Emoji autocomplete
    private bool showEmojiAutocomplete = false;
    private List<IrcChat.Client.Models.EmojiItem> filteredEmojis = [];
    private int selectedEmojiIndex = 0;
    private string currentEmojiQuery = string.Empty;
    private int emojiStartPosition = 0;

    // Emoji picker
    private bool isEmojiPickerOpen = false;

    [Parameter]
    public bool IsConnected { get; set; }

    [Parameter]
    public List<User>? AvailableUsers { get; set; }

    [Parameter]
    public EventCallback<string> OnSendMessage { get; set; }

    [Parameter]
    public EventCallback<string> OnInsertUsername { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && IsConnected)
        {
            await FocusAsync();
        }
    }

    private void ToggleEmojiPicker()
    {
        isEmojiPickerOpen = !isEmojiPickerOpen;
    }

    private void InsertEmoji(string emoji)
    {
        if (string.IsNullOrEmpty(messageInput))
        {
            messageInput = $"{emoji} ";
        }
        else if (messageInput.EndsWith(' '))
        {
            messageInput += $"{emoji} ";
        }
        else
        {
            messageInput += $" {emoji} ";
        }

        InvokeAsync(StateHasChanged);
    }

    private async Task SendMessage()
    {        
        if (!string.IsNullOrWhiteSpace(messageInput))
        {
            await OnSendMessage.InvokeAsync(messageInput.Trim());
            messageInput = string.Empty;
            HideAutoComplete();
            HideEmojiAutocomplete();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        // PrioritÃ© Ã  l'autocomplÃ©tion emoji si active
        if (showEmojiAutocomplete && filteredEmojis.Any())
        {
            switch (e.Key)
            {
                case "ArrowDown":
                    selectedEmojiIndex = (selectedEmojiIndex + 1) % filteredEmojis.Count;
                    StateHasChanged();
                    return;
                case "ArrowUp":
                    selectedEmojiIndex = selectedEmojiIndex <= 0 ? filteredEmojis.Count - 1 : selectedEmojiIndex - 1;
                    StateHasChanged();
                    return;
                case "Tab":
                case "Enter":
                    SelectEmojiFromAutocomplete(filteredEmojis[selectedEmojiIndex]);
                    StateHasChanged();
                    return;
                case "Escape":
                    HideEmojiAutocomplete();
                    StateHasChanged();
                    return;
            }
        }

        // Ensuite l'autocomplÃ©tion des mentions
        if (showAutoComplete && filteredUsers.Any())
        {
            switch (e.Key)
            {
                case "ArrowDown":
                    selectedUserIndex = (selectedUserIndex + 1) % filteredUsers.Count;
                    break;
                case "ArrowUp":
                    selectedUserIndex = selectedUserIndex <= 0 ? filteredUsers.Count - 1 : selectedUserIndex - 1;
                    break;
                case "Tab":
                case "Enter":
                    SelectUser(filteredUsers[selectedUserIndex].Username);
                    break;
                case "Escape":
                    HideAutoComplete();
                    break;
                default:
                    return;
            }
            StateHasChanged();
        }
        else if (e.Key == "Enter")
        {
            await SendMessage();
        }
        else if (e.Key == "Tab")
        {
            TryAutoCompleteFromCursor();
        }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key is "ArrowDown" or "ArrowUp" or "Enter" or "Tab" or "Escape")
        {
            return;
        }

        await CheckForMention();
        await CheckForEmoji();
    }

    private async Task CheckForMention()
    {
        if (string.IsNullOrEmpty(messageInput) || AvailableUsers == null || !AvailableUsers.Any())
        {
            HideAutoComplete();
            return;
        }

        var lastAtIndex = messageInput.LastIndexOf('@');

        if (lastAtIndex == -1)
        {
            HideAutoComplete();
            return;
        }

        if (lastAtIndex > 0 && !char.IsWhiteSpace(messageInput[lastAtIndex - 1]))
        {
            HideAutoComplete();
            return;
        }

        currentMentionQuery = messageInput.Substring(lastAtIndex + 1);
        mentionStartPosition = lastAtIndex;

        if (currentMentionQuery.Contains(' '))
        {
            HideAutoComplete();
            return;
        }

        filteredUsers = AvailableUsers
            .Where(u => u.Username.StartsWith(currentMentionQuery, StringComparison.OrdinalIgnoreCase))
            .Take(5)
            .ToList();

        if (filteredUsers.Any())
        {
            showAutoComplete = true;
            selectedUserIndex = 0;
            StateHasChanged();
        }
        else
        {
            HideAutoComplete();
        }

        await Task.CompletedTask;
    }

    private async Task CheckForEmoji()
    {
        if (string.IsNullOrEmpty(messageInput) || !EmojiService.IsLoaded)
        {
            HideEmojiAutocomplete();
            return;
        }

        var lastColonIndex = messageInput.LastIndexOf(':');

        if (lastColonIndex == -1)
        {
            HideEmojiAutocomplete();
            return;
        }

        if (lastColonIndex > 0 && !char.IsWhiteSpace(messageInput[lastColonIndex - 1]))
        {
            HideEmojiAutocomplete();
            return;
        }

        currentEmojiQuery = messageInput.Substring(lastColonIndex + 1);
        emojiStartPosition = lastColonIndex;

        if (currentEmojiQuery.Contains(' '))
        {
            HideEmojiAutocomplete();
            return;
        }

        filteredEmojis = EmojiService.SearchEmojis(currentEmojiQuery).Take(8).ToList();

        if (filteredEmojis.Any())
        {
            showEmojiAutocomplete = true;
            selectedEmojiIndex = 0;
            StateHasChanged();
        }
        else
        {
            HideEmojiAutocomplete();
        }

        await Task.CompletedTask;
    }

    private void TryAutoCompleteFromCursor()
    {
        if (string.IsNullOrEmpty(messageInput) || AvailableUsers == null || !AvailableUsers.Any())
        {
            return;
        }

        var words = messageInput.Split(' ');
        if (!words.Any())
        {
            return;
        }

        var lastWord = words[^1];
        if (string.IsNullOrEmpty(lastWord))
        {
            return;
        }

        var matchingUser = AvailableUsers
            .FirstOrDefault(u => u.Username.StartsWith(lastWord, StringComparison.OrdinalIgnoreCase));

        if (matchingUser != null)
        {
            var beforeLastWord = string.Join(" ", words.Take(words.Length - 1));
            messageInput = string.IsNullOrEmpty(beforeLastWord) 
                ? matchingUser.Username 
                : $"{beforeLastWord} {matchingUser.Username}";
            StateHasChanged();
        }
    }

    private void SelectUser(string username)
    {
        if (mentionStartPosition >= 0)
        {
            var before = messageInput.Substring(0, mentionStartPosition);
            var after = messageInput.Length > mentionStartPosition + currentMentionQuery.Length + 1
                ? messageInput.Substring(mentionStartPosition + currentMentionQuery.Length + 1)
                : string.Empty;

            messageInput = $"{before}{username} {after}";
        }

        HideAutoComplete();
        StateHasChanged();
    }

    private void SelectEmojiFromAutocomplete(IrcChat.Client.Models.EmojiItem emoji)
    {
        if (emojiStartPosition >= 0)
        {
            var before = messageInput.Substring(0, emojiStartPosition);
            var after = messageInput.Length > emojiStartPosition + currentEmojiQuery.Length + 1
                ? messageInput.Substring(emojiStartPosition + currentEmojiQuery.Length + 1)
                : string.Empty;

            messageInput = $"{before}{emoji.Emoji} {after}";
        }

        HideEmojiAutocomplete();
        StateHasChanged();
    }

    private void HideAutoComplete()
    {
        showAutoComplete = false;
        filteredUsers.Clear();
        currentMentionQuery = string.Empty;
        selectedUserIndex = 0;
    }

    private void HideEmojiAutocomplete()
    {
        showEmojiAutocomplete = false;
        filteredEmojis.Clear();
        currentEmojiQuery = string.Empty;
        selectedEmojiIndex = 0;
    }

    public async Task FocusAsync()
    {
        try
        {
            await inputElement.FocusAsync();
        }
        catch
        {
            // Ignorer les erreurs de focus
        }
    }

    public void InsertUsername(string username)
    {
        if (string.IsNullOrEmpty(messageInput))
        {
            messageInput = $"{username} ";
        }
        else if (messageInput.EndsWith(' '))
        {
            messageInput += $"{username} ";
        }
        else
        {
            messageInput += $" {username} ";
        }

        InvokeAsync(StateHasChanged);
    }
}
