@using IrcChat.Client.Extensions
@using IrcChat.Shared.Models
@using System.Diagnostics.CodeAnalysis
@using System.Text.RegularExpressions
@inject IJSRuntime JSRuntime
@inject ILogger<MessageList> Logger
@implements IAsyncDisposable

<div class="messages" @ref="messagesContainer">
    @foreach (var msg in Messages)
    {
        var isMentioned = IsMentioned(msg.Content, CurrentUsername);
        <div class="message @(msg.Username == CurrentUsername ? "own" : string.Empty) @(isMentioned ? "mentioned" : string.Empty)">
            <span class="username">@msg.Username</span>
            <span class="time">@msg.Timestamp.ToLocalTime().ToMessageTimeString()</span>
            <span class="content">@((MarkupString)HighlightMention(msg.Content, CurrentUsername))</span>
        </div>
    }
</div>

@code {
    private ElementReference messagesContainer;
    private IJSObjectReference? scrollModule;
    private int previousMessageCount = 0;
    private bool isUserScrolling = false;
    private DotNetObjectReference<MessageList>? dotNetReference;
    private List<Message> messages = new();

    [Parameter]
    [SuppressMessage("Blazor", "BL0007", Justification = "Reset previous message count on set")]
    public List<Message> Messages
    {
        get => messages;
        set
        {
            messages = value;
            previousMessageCount = 0;
        }
    }

    [Parameter]
    public string CurrentUsername { get; set; } = string.Empty;

    private bool IsMentioned(string content, string username)
    {
        if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(content))
            return false;

        // Vérifier si le pseudo est présent dans le contenu (insensible à la casse)
        return content.Contains(username, StringComparison.OrdinalIgnoreCase);
    }

    private string HighlightMention(string content, string username)
    {
        if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(content))
            return System.Net.WebUtility.HtmlEncode(content);

        // Échapper le HTML pour éviter les injections XSS
        var escapedContent = System.Net.WebUtility.HtmlEncode(content);
        var escapedUsername = System.Text.RegularExpressions.Regex.Escape(username);

        // Créer un pattern regex pour trouver le pseudo (insensible à la casse)
        var pattern = $@"\b({escapedUsername})\b";
        var regex = new Regex(pattern, RegexOptions.IgnoreCase, TimeSpan.FromSeconds(1));

        // Remplacer toutes les occurrences par une version mise en évidence
        var highlighted = regex.Replace(escapedContent,
            match => $"<span class=\"mention-highlight\">{match.Value}</span>");

        return highlighted;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                scrollModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./js/scroll-helper.js");

                // Créer une référence .NET pour les callbacks JS
                dotNetReference = DotNetObjectReference.Create(this);

                // Attacher le listener de scroll pour détecter le scroll manuel
                await scrollModule.InvokeVoidAsync("attachScrollListener",
                    messagesContainer,
                    dotNetReference);

            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Erreur lors du chargement du module de scroll.");
            }
        }

        // Auto-scroll uniquement si de nouveaux messages arrivent ET que l'utilisateur n'est pas en train de scroller
        if (Messages.Count > previousMessageCount)
        {
            previousMessageCount = Messages.Count;

            // Ne scroll que si l'utilisateur n'a pas scrollé manuellement vers le haut
            if (!isUserScrolling)
            {
                await ScrollToBottomAsync();
            }
        }
    }

    private async Task ScrollToBottomAsync()
    {
        if (scrollModule != null)
        {
            try
            {
                await scrollModule.InvokeVoidAsync("scrollToBottom", messagesContainer);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Erreur lors de l'appel scroll to bottom.");
            }
        }
    }

    /// <summary>
    /// Méthode appelée par JavaScript quand l'utilisateur scroll
    /// </summary>
    [JSInvokable]
    public void OnUserScroll(bool isAtBottom)
    {
        // Si l'utilisateur est en bas, on réactive le scroll automatique
        // Sinon, on le désactive (il est en train de lire des messages plus anciens)
        isUserScrolling = !isAtBottom;
    }

    public async ValueTask DisposeAsync()
    {
        if (scrollModule != null)
        {
            try
            {
                await scrollModule.DisposeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Erreur lors de la libération du module de scroll.");
            }
        }

        // Libérer la référence .NET
        dotNetReference?.Dispose();

        GC.SuppressFinalize(this);
    }
}
