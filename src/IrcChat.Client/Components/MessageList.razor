@using IrcChat.Shared.Models
@inject IJSRuntime JSRuntime
@inject ILogger<MessageList> Logger
@implements IAsyncDisposable

<div class="messages" @ref="messagesContainer">
    @foreach (var msg in Messages)
    {
        <div class="message @(msg.Username == CurrentUsername ? "own" : string.Empty)">
            <span class="username">@msg.Username</span>
            <span class="time">@msg.Timestamp.ToLocalTime().ToString("HH:mm")</span>
            <span class="content">@msg.Content</span>
        </div>
    }
</div>

@code {
    private ElementReference messagesContainer;
    private IJSObjectReference? scrollModule;
    private int previousMessageCount = 0;

    [Parameter]
    public List<Message> Messages { get; set; } = new();

    [Parameter]
    public string CurrentUsername { get; set; } = string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                scrollModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./js/scroll-helper.js");
            }
            catch (Exception ex)
            {
                // Gérer l'erreur silencieusement si le module ne peut pas être chargé
                Logger.LogWarning(ex, "Erreur lors du chargement du module de scroll.");
            }
        }

        // Scroll automatique si de nouveaux messages arrivent
        if (Messages.Count > previousMessageCount)
        {
            previousMessageCount = Messages.Count;
            await ScrollToBottom();
        }
    }

    private async Task ScrollToBottom()
    {
        if (scrollModule != null)
        {
            try
            {
                await scrollModule.InvokeVoidAsync("scrollToBottom", messagesContainer);
            }
            catch
            {
                // Ignorer les erreurs de scroll
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (scrollModule != null)
        {
            try
            {
                await scrollModule.DisposeAsync();
            }
            catch (Exception ex)
            {
                // Ignorer les erreurs de dispose
                Logger.LogWarning(ex, "Erreur lors de la libération du module de scroll.");
            }
        }

        GC.SuppressFinalize(this);
    }
}
