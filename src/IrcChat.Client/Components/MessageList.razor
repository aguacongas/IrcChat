@using IrcChat.Client.Extensions
@using IrcChat.Shared.Models
@using System.Diagnostics.CodeAnalysis
@using System.Text.RegularExpressions
@inject IJSRuntime JSRuntime
@inject ILogger<MessageList> Logger
@implements IAsyncDisposable

@if (ShowDescription)
{
    <div class="channel-description-header @(isHeaderCollapsed ? "collapsed" : "expanded")"
         @onclick="ToggleHeaderExpand">
        <div class="description-header-content">
            @if (!string.IsNullOrEmpty(ChannelDescription))
            {
                <div class="description-text">
                    @foreach (var line in ChannelDescription.Split('\n'))
                    {
                        @line
                        <br />
                    }
                </div>                
            }
            else
            {
                <div class="description-text empty">
                    <em>Aucune description</em>
                </div>
            }
            @if (CanManage)
            {
                <button class="edit-description-btn"
                        @onclick="HandleEditClick"
                        @onclick:stopPropagation="true"
                        title="Modifier la description">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                </button>
            }
        </div>
    </div>
}
<div class="messages" @ref="messagesContainer">
    @foreach (var msg in Messages)
    {
        var isMentioned = IsMentioned(msg.Content, CurrentUsername);
        <div class="message @(msg.Username == CurrentUsername ? "own" : string.Empty) @(isMentioned ? "mentioned" : string.Empty)">
            <span class="username" @onclick="() => OnUsernameClick(msg.Username)">@msg.Username</span>
            <span class="time">@msg.Timestamp.ToLocalTime().ToMessageTimeString()</span>
            <span class="content">@((MarkupString)HighlightMention(msg.Content, CurrentUsername))</span>
            @if (CanManage)
            {
                <button class="btn-delete-message"
                        @onclick="() => OnDeleteMessage.InvokeAsync(msg.Id)"
                        title="Supprimer ce message">
                    üóëÔ∏è
                </button>
            }
        </div>
    }
</div>

@code {
    private bool isHeaderCollapsed = false;
    private ElementReference messagesContainer;
    private IJSObjectReference? scrollModule;
    private int previousMessageCount = 0;
    private bool isUserScrolling = false;
    private DotNetObjectReference<MessageList>? dotNetReference;
    private List<Message> messages = new();

    [Parameter]
    [SuppressMessage("Blazor", "BL0007", Justification = "Reset previous message count on set")]
    public List<Message> Messages
    {
        get => messages;
        set
        {
            messages = value;
            previousMessageCount = 0;
        }
    }

    [Parameter]
    public string CurrentUsername { get; set; } = string.Empty;

    [Parameter]
    public string? ChannelDescription { get; set; }

    [Parameter]
    public bool ShowDescription { get; set; }

    [Parameter]
    public bool CanManage { get; set; }

    [Parameter]
    public EventCallback OnEditDescription { get; set; }

    [Parameter]
    public EventCallback<string> OnUsernameClicked { get; set; }

    [Parameter]
    public EventCallback<Guid> OnDeleteMessage { get; set; }

    private async Task OnUsernameClick(string username)
    {
        // Ne pas mentionner son propre pseudo
        if (username == CurrentUsername)
        {
            return;
        }

        await OnUsernameClicked.InvokeAsync(username);
    }

    private static bool IsMentioned(string content, string username)
    {
        if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(content))
            return false;

        // V√©rifier si le pseudo est pr√©sent dans le contenu (insensible √† la casse)
        return content.Contains(username, StringComparison.OrdinalIgnoreCase);
    }

    private static string HighlightMention(string content, string username)
    {
        if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(content))
            return System.Net.WebUtility.HtmlEncode(content);

        // √âchapper le HTML pour √©viter les injections XSS
        var escapedContent = System.Net.WebUtility.HtmlEncode(content);
        var escapedUsername = System.Text.RegularExpressions.Regex.Escape(username);

        // Cr√©er un pattern regex pour trouver le pseudo (insensible √† la casse)
        var pattern = $@"\b({escapedUsername})\b";
        var regex = new Regex(pattern, RegexOptions.IgnoreCase, TimeSpan.FromSeconds(1));

        // Remplacer toutes les occurrences par une version mise en √©vidence
        var highlighted = regex.Replace(escapedContent,
            match => $"<span class=\"mention-highlight\">{match.Value}</span>");

        return highlighted;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                scrollModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./js/scroll-helper.js");

                // Cr√©er une r√©f√©rence .NET pour les callbacks JS
                dotNetReference = DotNetObjectReference.Create(this);

                // Attacher le listener de scroll pour d√©tecter le scroll manuel
                await scrollModule.InvokeVoidAsync("attachScrollListener",
                    messagesContainer,
                    dotNetReference);

            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Erreur lors du chargement du module de scroll.");
            }
        }

        // Auto-scroll uniquement si de nouveaux messages arrivent ET que l'utilisateur n'est pas en train de scroller
        if (Messages.Count > previousMessageCount)
        {
            previousMessageCount = Messages.Count;

            // Ne scroll que si l'utilisateur n'a pas scroll√© manuellement vers le haut
            if (!isUserScrolling)
            {
                await ScrollToBottomAsync();
            }
        }
    }

    private async Task ScrollToBottomAsync()
    {
        if (scrollModule != null)
        {
            try
            {
                await scrollModule.InvokeVoidAsync("scrollToBottom", messagesContainer);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Erreur lors de l'appel scroll to bottom.");
            }
        }
    }

    private Task HandleEditClick()
    => OnEditDescription.InvokeAsync();

    /// <summary>
    /// M√©thode appel√©e par JavaScript quand l'utilisateur scroll
    /// </summary>
    [JSInvokable]
    public void OnUserScroll(bool isAtBottom)
    {
        // Si l'utilisateur est en bas, on r√©active le scroll automatique
        // Sinon, on le d√©sactive (il est en train de lire des messages plus anciens)
        isUserScrolling = !isAtBottom;
    }

    /// <summary>
    /// M√©thode appel√©e par JavaScript pour g√©rer le collapse du header
    /// </summary>
    [JSInvokable]
    public void OnScrollPositionChanged(bool shouldCollapse)
    {
        // Ne pas changer l'√©tat si l'utilisateur a forc√© l'expansion
        if (isHeaderCollapsed != shouldCollapse)
        {
            isHeaderCollapsed = shouldCollapse;
            InvokeAsync(StateHasChanged);
        }
    }

    private void ToggleHeaderExpand()
    {
        isHeaderCollapsed = !isHeaderCollapsed;
    }

    public async ValueTask DisposeAsync()
    {
        if (scrollModule != null)
        {
            try
            {
                await scrollModule.DisposeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Erreur lors de la lib√©ration du module de scroll.");
            }
        }

        // Lib√©rer la r√©f√©rence .NET
        dotNetReference?.Dispose();

        GC.SuppressFinalize(this);
    }
}
