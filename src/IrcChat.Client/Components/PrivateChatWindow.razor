@using IrcChat.Shared.Models
@inject IJSRuntime JSRuntime
@inject ILogger<PrivateChatWindow> Logger
@implements IAsyncDisposable

<div class="private-chat-window">
    <div class="private-chat-header">
        <div class="header-left">
            <h3>ðŸ’¬ @OtherUsername</h3>
            <span class="status-indicator online">En ligne</span>
        </div>
        <button class="close-btn" @onclick="OnClose">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
    </div>

    <div class="messages-container" @ref="messagesContainer">
        @if (Messages.Any())
        {
            @foreach (var msg in Messages)
            {
                <div class="private-message @(msg.SenderUsername == CurrentUsername ? "sent" : "received")">
                    <span class="sender">@msg.SenderUsername</span>
                    <span class="time">@msg.Timestamp.ToLocalTime().ToString("HH:mm")</span>
                    <span class="message-content">@msg.Content</span>
                    @if (msg.SenderUsername == CurrentUsername && msg.IsRead)
                    {
                        <span class="read-indicator">âœ“âœ“</span>
                    }
                </div>
            }
        }
        else
        {
            <div class="empty-messages">
                <p>Aucun message avec @OtherUsername</p>
                <small>Envoyez un message pour dÃ©marrer la conversation</small>
            </div>
        }
    </div>

    <div class="input-area">
        <input @bind="messageInput"
               @bind:event="oninput"
               placeholder="Ã‰crivez votre message..."
               @onkeyup="HandleKeyUp"
               disabled="@(!IsConnected)" />
        <button @onclick="SendMessage"
                disabled="@(!IsConnected || string.IsNullOrWhiteSpace(messageInput))">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        </button>
    </div>
</div>

@code {
    private ElementReference messagesContainer;
    private IJSObjectReference? scrollModule;
    private string messageInput = string.Empty;
    private int previousMessageCount = 0;
    private bool isUserScrolling = false;

    [Parameter]
    public string CurrentUsername { get; set; } = string.Empty;

    [Parameter]
    public string OtherUsername { get; set; } = string.Empty;

    [Parameter]
    public List<PrivateMessage> Messages { get; set; } = new();

    [Parameter]
    public bool IsConnected { get; set; }

    [Parameter]
    public EventCallback<string> OnSendMessage { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                scrollModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./js/scroll-helper.js");

                // Attacher le listener de scroll pour dÃ©tecter le scroll manuel
                await scrollModule.InvokeVoidAsync("attachScrollListener",
                    messagesContainer,
                    DotNetObjectReference.Create(this));
            }
            catch (Exception ex)
            {
                // GÃ©rer l'erreur silencieusement
                Logger.LogWarning(ex, "Erreur lors du chargement du module de scroll.");
            }
        }

        // Auto-scroll si de nouveaux messages arrivent et que l'utilisateur ne scrolle pas
        if (Messages.Count > previousMessageCount)
        {
            previousMessageCount = Messages.Count;

            if (!isUserScrolling)
            {
                await ScrollToBottom();
            }
        }
    }

    private async Task ScrollToBottom()
    {
        if (scrollModule != null)
        {
            try
            {
                await scrollModule.InvokeVoidAsync("scrollToBottom", messagesContainer);
            }
            catch
            {
                // Ignorer les erreurs de scroll
            }
        }
    }

    private async Task SendMessage()
    {
        if (!string.IsNullOrWhiteSpace(messageInput))
        {
            await OnSendMessage.InvokeAsync(messageInput.Trim());
            messageInput = string.Empty;

            // Force le scroll aprÃ¨s l'envoi
            isUserScrolling = false;
            await ScrollToBottom();
        }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(messageInput))
        {
            await SendMessage();
        }
    }

    [JSInvokable]
    public void OnUserScroll(bool isAtBottom)
    {
        isUserScrolling = !isAtBottom;
    }

    public async ValueTask DisposeAsync()
    {
        if (scrollModule != null)
        {
            try
            {
                await scrollModule.DisposeAsync();
            }
            catch (Exception ex)
            {
                // Ignorer les erreurs de dispose
                Logger.LogWarning(ex, "Erreur lors de la libÃ©ration du module de scroll.");
            }
        }

        GC.SuppressFinalize(this);
    }
}
