@* src/IrcChat.Client/Pages/Chat.razor *@
@page "/chat"
@page "/chat/channel/{ChannelName}"
@page "/chat/private/{PrivateUserId}/{PrivateUsername?}"
@using IrcChat.Client.Extensions
@using IrcChat.Client.Models
@using IrcChat.Shared.Models
@using IrcChat.Client.Services
@using IrcChat.Client.Components
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Extensions.Options
@using System.Net.Http.Headers
@using System.Diagnostics.CodeAnalysis
@inject HttpClient Http
@inject IChatService ChatService
@inject IUnifiedAuthService Auth
@inject IPrivateMessageService PrivateMessageService
@inject NavigationManager Navigation
@inject IOptions<ApiSettings> ApiSettingsOptions
@inject ILogger<Chat> Logger
@inject IDeviceDetectorService DeviceDetector
@inject IIgnoredUsersService IgnoredUsersService
@implements IAsyncDisposable

<PageTitle>IRC Chat</PageTitle>

@if (!isInitialized)
{
    <div class="loading">
        <div class="spinner"></div>
        <p>Chargement...</p>
    </div>
}
else if (!Auth.HasUsername)
{
    <p>Redirection vers la page de connexion...</p>
}
else
{
    <SidebarToggleButton IsOpen="sidebarOpen"
                         UnreadCount="totalUnreadCount"
                         OnToggle="HandleSidebarToggle" />

    <div class="chat-container @(sidebarOpen ? "sidebar-open" : "sidebar-closed")">
        <Sidebar IsOpen="sidebarOpen"
                 Username="@currentUsername"
                 AvatarUrl="@avatarUrl"
                 IsOAuthUser="@Auth.IsReserved"
                 IsAdmin="@Auth.IsAdmin"
                 CurrentChannel="@currentChannel"
                 Channels="@channels"
                 Users="@users"
                 PrivateConversations="@privateConversations"
                 SelectedPrivateUser="@selectedPrivateUser"
                 OnChannelSelected="SwitchChannel"
                 OnUserClicked="StartPrivateChat"
                 OnPrivateConversationSelected="StartPrivateChat"
                 OnConversationDeleted="DeleteConversation"
                 OnUserInfoClicked="GoToSettings"
                 OnChannelDeleted="HandleChannelDeleted"
                 OnBrowseChannelsClicked="HandleBrowseChannels"
                 OnChannelLeave="HandleLeaveChannel" />

        @* Afficher ChannelList si aucun salon ni conversation priv√©e active *@
        @if (string.IsNullOrEmpty(currentChannel) && !isPrivateConversation)
        {
            <ChannelList OnChannelSelected="HandleChannelListSelection" />
        }
        else
        {
            <ChatArea @key="@GetChatAreaKey()"
                      Username="@currentUsername"
                      CurrentContactUserId="@selectedPrivateUser?.UserId"
                      CurrentChannel="@GetCurrentChannelOrUsername()"
                      ChannelDescription="@currentChannelDescription"
                      IsConnected="@IsConnected"
                      Messages="@GetCurrentMessages()"
                      Users="@(isPrivateConversation ? null : users)"
                      IsMuted="@isCurrentChannelMuted"
                      CanManage="@CanManageCurrentChannel()"
                      UsersListOpen="@usersListOpen"
                      IsPrivateConversation="@isPrivateConversation"
                      IsUserOnline="@isSelectedUserOnline"
                      OnMessageSent="@(isPrivateConversation ? SendPrivateMessage : SendMessage)"
                      OnUserClicked="HandleUserClicked"
                      OnMuteStatusChanged="HandleMuteStatusChanged"
                      OnClosePrivateConversation="ClosePrivateChat"
                      OnChannelDeleted="HandleChannelDeleted"
                      OnUsersListToggle="HandleUsersListToggle"
                      OnChannelUpdated="HandleChannelUpdated" />
        }
    </div>

    @* Notification de mute *@
    @if (!string.IsNullOrEmpty(muteNotification))
    {
        <div class="mute-notification">
            @muteNotification
        </div>
    }

    @* Notification de connexion *@
    @if (!string.IsNullOrEmpty(connectionNotification))
    {
        <div class="connection-notification @connectionNotificationClass">
            <div class="notification-icon">
                @if (connectionNotificationType == ConnectionNotificationType.Disconnected)
                {
                    <span>‚ö†Ô∏è</span>
                }
                else if (connectionNotificationType == ConnectionNotificationType.Reconnecting)
                {
                    <span class="spinner-small"></span>
                }
                else if (connectionNotificationType == ConnectionNotificationType.Reconnected)
                {
                    <span>‚úì</span>
                }
            </div>
            <div class="notification-content">
                @connectionNotification
            </div>
        </div>
    }
}

@code {
    [Parameter]
    public string? ChannelName { get; set; }

    [Parameter]
    public string? PrivateUserId { get; set; }

    [Parameter]
    public string? PrivateUsername { get; set; }

    private string? currentChannel = null;
    private string? currentChannelDescription = null;
    private string currentUsername = "";
    private string currentUserId = "";
    private string? avatarUrl = null;
    private List<Message> messages = new();
    private List<Channel> channels = new();
    private List<User> users = new();
    private bool isInitialized = false;
    private bool isCurrentChannelMuted = false;
    private string muteNotification = "";
    private bool sidebarOpen = false;
    private bool usersListOpen = false;
    private int totalUnreadCount => privateConversations.Sum(c => c.UnreadCount);
    private bool isDataLoaded = false;
    private bool isApplyingRoute = false;

    // Notifications de connexion
    private string connectionNotification = "";
    private string connectionNotificationClass = "";
    private ConnectionNotificationType connectionNotificationType = ConnectionNotificationType.None;    

    // Messages priv√©s
    private List<PrivateConversation> privateConversations = new();
    private List<PrivateMessage> privateMessages = new();
    private User? selectedPrivateUser = null;
    private bool isPrivateConversation = false;
    private bool isSelectedUserOnline = false;

    private bool IsConnected => ChatService.IsInitialized;


    protected override async Task OnInitializedAsync()
    {
        await Auth.InitializeAsync();
        await IgnoredUsersService.InitializeAsync();
        isInitialized = true;

        if (!Auth.HasUsername)
        {
            Navigation.NavigateToRelative("login");
            return;
        }

        currentUsername = Auth.Username!;
        currentUserId = await Auth.GetClientUserIdAsync();
        avatarUrl = Auth.AvatarUrl;

        // D√©terminer l'√©tat initial de la liste des utilisateurs selon la taille d'√©cran
        usersListOpen = !await DeviceDetector.IsMobileDeviceAsync();

        if (!string.IsNullOrEmpty(currentUsername))
        {
            if (Auth.IsAuthenticated && !string.IsNullOrEmpty(Auth.Token))
            {
                Http.DefaultRequestHeaders.Authorization =
                    new AuthenticationHeaderValue("Bearer", Auth.Token);
            }

            try
            {
                await InitializeSignalR();
                await LoadMyChannels();
                await LoadPrivateConversations();
            }
            finally
            {
                isDataLoaded = true;
            }

            await ApplyRouteStateAsync();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (!isDataLoaded || !Auth.HasUsername)
        {
            return;
        }

        await ApplyRouteStateAsync();
    }

    private async Task ApplyRouteStateAsync()
    {
        if (isApplyingRoute)
        {
            return;
        }

        try
        {
            isApplyingRoute = true;

            if (!string.IsNullOrEmpty(PrivateUserId))
            {
                if (!isPrivateConversation ||
                    !string.Equals(selectedPrivateUser?.UserId, PrivateUserId, StringComparison.Ordinal))
                {
                    var routeUser = ResolveUserFromRoute(PrivateUserId, PrivateUsername);
                    await OpenPrivateChatInternal(routeUser);
                }

                return;
            }

            if (!string.IsNullOrEmpty(ChannelName))
            {
                if (isPrivateConversation ||
                    !string.Equals(currentChannel, ChannelName, StringComparison.OrdinalIgnoreCase))
                {
                    await JoinChannelInternal(ChannelName);
                }

                return;
            }

            if (isPrivateConversation)
            {
                ClosePrivateChatState();
            }
        }
        finally
        {
            isApplyingRoute = false;
        }
    }

    private async Task InitializeSignalR()
    {
        ChatService.OnMessageReceived += OnMessageReceived;
        ChatService.OnUserJoined += OnUserJoined;
        ChatService.OnUserLeft += OnUserLeft;
        ChatService.OnChannelDeleted += OnChannelDeleted;
        ChatService.OnChannelNotFound += OnChannelNotFound;
        ChatService.OnChannelListUpdated += OnChannelListUpdated;
        ChatService.OnUserStatusChanged += OnUserStatusChanged;
        ChatService.OnUserMuted += OnUserMutedSignalR;
        ChatService.OnUserUnmuted += OnUserUnmutedSignalR;

        PrivateMessageService.OnPrivateMessageReceived += OnPrivateMessageReceived;
        PrivateMessageService.OnPrivateMessageSent += OnPrivateMessageSent;
        PrivateMessageService.OnUnreadCountChanged += OnUnreadCountChanged;
        PrivateMessageService.OnConversationDeleted += OnConversationDeleted;

        // √âv√©nements de connexion
        ChatService.OnDisconnected += OnSignalRDisconnected;
        ChatService.OnReconnecting += OnSignalRReconnecting;
        ChatService.OnReconnected += OnSignalRReconnected;

        IgnoredUsersService.OnIgnoredUsersChanged += OnIgnoredUsersChanged;

        if (ChatService.IsInitialized)
        {
            return;
        }

        try
        {
            var apiSettings = ApiSettingsOptions.Value;
            var hubUrl = !string.IsNullOrEmpty(apiSettings.SignalRHubUrl)
              ? apiSettings.SignalRHubUrl
              : $"{apiSettings.BaseUrl}/chathub";

            var hubConnectionBuilder = new HubConnectionBuilder()
                .WithUrl(hubUrl, options =>
                {
                    options.AccessTokenProvider = () => Task.FromResult(Auth.Token);
                })
                .WithAutomaticReconnect();
            await ChatService.InitializeAsync(hubConnectionBuilder);

            ChatService.OnChannelMuteStatusChanged += OnChannelMuteStatusChanged;
            ChatService.OnMessageBlocked += OnMessageBlocked;

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors de l'initialisation de SignalR");
            ShowConnectionNotification("√âchec de connexion au serveur", ConnectionNotificationType.Disconnected);
        }
    }

    // Handlers pour les √©v√©nements de connexion SignalR
    private void OnSignalRDisconnected()
    {
        InvokeAsync(() =>
        {
            ShowConnectionNotification("Connexion perdue. Tentative de reconnexion...", ConnectionNotificationType.Disconnected);
            StateHasChanged();
        });
    }

    private void OnSignalRReconnecting(string? error)
    {
        InvokeAsync(() =>
        {
            var message = string.IsNullOrEmpty(error)
                ? "Reconnexion en cours..."
                : $"Reconnexion en cours... ({error})";
            ShowConnectionNotification(message, ConnectionNotificationType.Reconnecting, persistent: true);
            StateHasChanged();
        });
    }

    private void OnSignalRReconnected()
    {
        InvokeAsync(async () =>
        {
            ShowConnectionNotification("Reconnexion r√©ussie !", ConnectionNotificationType.Reconnected);

            // Recharger les donn√©es apr√®s reconnexion
            await LoadMyChannels();
            if (!isPrivateConversation && !string.IsNullOrEmpty(currentChannel))
            {
                await LoadMessages();
                await LoadUsers();
            }
            else if (selectedPrivateUser is not null)
            {
                await LoadPrivateMessages(selectedPrivateUser.UserId);
            }
            await LoadPrivateConversations();

            StateHasChanged();
        });
    }

    private void ShowConnectionNotification(string message, ConnectionNotificationType type, bool persistent = false)
    {
        connectionNotification = message;
        connectionNotificationType = type;

        connectionNotificationClass = type switch
        {
            ConnectionNotificationType.Disconnected => "error",
            ConnectionNotificationType.Reconnecting => "warning",
            ConnectionNotificationType.Reconnected => "success",
            _ => ""
        };

        StateHasChanged();

        if (!persistent)
        {
            // Auto-masquer apr√®s 4 secondes (sauf pour "Reconnecting" qui est persistant)
            _ = Task.Run(async () =>
            {
                await Task.Delay(4000);
                await InvokeAsync(() =>
                {
                    connectionNotification = "";
                    connectionNotificationType = ConnectionNotificationType.None;
                    StateHasChanged();
                });
            });
        }
    }

    // Handlers pour canaux publics
    private void OnMessageReceived(Message message)
    {
        InvokeAsync(() =>
        {
            if (message.Channel == currentChannel &&
              !isPrivateConversation &&
              !IgnoredUsersService.IsUserIgnored(message.UserId))
            {
                messages.Add(message);
                StateHasChanged();
            }
        });
    }

    private void OnUserJoined(string user, string userId, string channel)
    {
        if (channel == currentChannel && !isPrivateConversation && !users.Any(u => u.Username == user))
        {
            users.Add(new User { Username = user, UserId = userId });
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnUserLeft(string user, string userId, string channel)
    {
        if (channel == currentChannel && !isPrivateConversation)
        {
            users = users.Where(u => u.UserId != userId).ToList();
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnChannelMuteStatusChanged(string channel, bool isMuted)
    {        
        if (channel == currentChannel && !isPrivateConversation)
        {
            isCurrentChannelMuted = isMuted;
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnMessageBlocked(string reason)
    {
        muteNotification = reason;
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await Task.Delay(4000);
            muteNotification = "";
            StateHasChanged();
        });
    }

    private void OnUserMutedSignalR(string channel, string userId, string username, string mutedByUserId, string mutedByUsername)
    {
        InvokeAsync(async () =>
        {
            Logger.LogInformation("Utilisateur {Username} rendu mute dans {Channel} par {MutedBy}", username, channel, mutedByUsername);

            // Actualiser la liste des utilisateurs si c'est le salon courant
            if (channel == currentChannel && !isPrivateConversation)
            {
                await LoadUsers();
            }

            StateHasChanged();
        });
    }

    private void OnUserUnmutedSignalR(string channel, string userId, string username, string unmutedByUserId, string unmutedByUsername)
    {
        InvokeAsync(async () =>
        {
            Logger.LogInformation("Utilisateur {Username} re√ßoit la parole dans {Channel} par {UnmutedBy}", username, channel, unmutedByUsername);

            // Actualiser la liste des utilisateurs si c'est le salon courant
            if (channel == currentChannel && !isPrivateConversation)
            {
                await LoadUsers();
            }

            StateHasChanged();
        });
    }

    private async void OnChannelDeleted(string channelName)
    {
        channels = channels.Where(c => c.Name != channelName).ToList();

        if (currentChannel == channelName && !isPrivateConversation)
        {
            currentChannel = null;
            currentChannelDescription = null;
            messages.Clear();
            NavigateToRelativeIfNeeded("chat");
        }

        await InvokeAsync(StateHasChanged);
    }

    private void OnChannelNotFound(string channelName)
    {
        muteNotification = $"Le salon #{channelName} n'existe plus";
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await Task.Delay(4000);
            muteNotification = "";
            StateHasChanged();
        });
    }

    private async void OnChannelListUpdated()
    {
        await LoadMyChannels();
        await InvokeAsync(StateHasChanged);
    }

    private async void OnUserStatusChanged(string username, bool isOnline)
    {
        // Mettre √† jour le statut dans les conversations
        var conversation = privateConversations.FirstOrDefault(c => c.OtherUser?.Username == username);
        if (conversation != null)
        {
            conversation.IsOnline = isOnline;
        }

        // Mettre √† jour le statut de l'utilisateur s√©lectionn√©
        if (isPrivateConversation && selectedPrivateUser?.Username == username)
        {
            isSelectedUserOnline = isOnline;
        }

        await InvokeAsync(StateHasChanged);
    }

    private Task HandleChannelDeleted(string channelName)
    {
        OnChannelDeleted(channelName);
        return Task.CompletedTask;
    }

    private async Task HandleChannelListSelection(string channelName)
    {
        NavigateToChannelRoute(channelName);
        await Task.CompletedTask;
    }

    private void HandleBrowseChannels()
    {
        // Fermer toute conversation priv√©e
        if (isPrivateConversation)
        {
            ClosePrivateChatState();
        }

        // Quitter le salon actuel (visuellement, pas via SignalR)
        currentChannel = string.Empty;
        messages.Clear();
        users.Clear();

        // Fermer la sidebar sur mobile
        sidebarOpen = false;

        // Naviguer vers la route de base /chat pour afficher ChannelList
        NavigateToRelativeIfNeeded("chat");

        StateHasChanged();
    }

    private async Task HandleLeaveChannel(string channelName)
    {
        if (string.IsNullOrWhiteSpace(channelName))
        {
            return;
        }

        try
        {
            Logger.LogInformation("Quitter le salon {Channel}", channelName);

            // Appeler SignalR pour quitter le salon
            await ChatService.LeaveChannel(channelName);

            // Recharger la liste des salons connect√©s
            channels = channels.Where(c => c.Name != channelName).ToList();

            // Si c'est le salon actuel, basculer vers un autre ou afficher ChannelList
            if (currentChannel == channelName && !isPrivateConversation)
            {
                var otherChannel = channels.FirstOrDefault(c => c.Name != channelName);
                if (otherChannel != null)
                {
                    // Basculer vers un autre salon
                    NavigateToChannelRoute(otherChannel.Name);
                }
                else
                {
                    // Plus de salons connect√©s, afficher ChannelList
                    currentChannel = null;
                    currentChannelDescription = null;
                    messages.Clear();
                    users.Clear();
                    NavigateToRelativeIfNeeded("chat");
                }
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors de la sortie du salon {Channel}", channelName);
            muteNotification = $"Impossible de quitter le salon {channelName}";
            StateHasChanged();
            await Task.Delay(4000);
            muteNotification = "";
            StateHasChanged();
        }
    }

    // Handlers pour messages priv√©s
    private void OnPrivateMessageReceived(PrivateMessage message)
    {
        InvokeAsync(async () =>
        {
            if (isPrivateConversation &&
              (message.SenderUserId == selectedPrivateUser?.UserId || message.RecipientUserId == selectedPrivateUser?.UserId) &&
              !(IgnoredUsersService.IsUserIgnored(message.SenderUserId)))
            {
                privateMessages.Add(message);

                if (message.SenderUserId == selectedPrivateUser?.UserId)
                {
                    _ = ChatService.MarkPrivateMessagesAsRead(selectedPrivateUser!.UserId);
                }
            }

            await LoadPrivateConversations();
            StateHasChanged();
        });
    }

    private void OnPrivateMessageSent(PrivateMessage message)
    {
        if (isPrivateConversation && message.RecipientUserId == selectedPrivateUser?.UserId)
        {
            privateMessages.Add(message);
        }

        InvokeAsync(async () =>
        {
            await LoadPrivateConversations();
            StateHasChanged();
        });
    }

    private void OnUnreadCountChanged()
    {
        InvokeAsync(async () =>
        {
            await LoadPrivateConversations();
            StateHasChanged();
        });
    }

    private void OnConversationDeleted(string username)
    {
        if (selectedPrivateUser?.UserId == username && isPrivateConversation)
        {
            ClosePrivateChat();
        }

        InvokeAsync(async () =>
        {
            await LoadPrivateConversations();
            StateHasChanged();
        });
    }

    private void OnIgnoredUsersChanged()
    {
        InvokeAsync(async () =>
        {
            // Recharger les messages priv√©s si une conversation est ouverte
            if (isPrivateConversation && selectedPrivateUser != null)
            {
                await OpenPrivateChatInternal(selectedPrivateUser);
                StateHasChanged();
            }
        });
    }

    // Actions
    private void GoToSettings()
    {
        Navigation.NavigateToRelative("settings");
    }

    private Task SwitchChannel(string channel)
    {
        NavigateToChannelRoute(channel);
        return Task.CompletedTask;
    }

    private async Task JoinChannelInternal(string channel)
    {
        if (string.IsNullOrWhiteSpace(channel))
        {
            return;
        }

        // V√©rifier si d√©j√† connect√©
        var alreadyConnected = channels.Any(c => c.Name.Equals(channel, StringComparison.OrdinalIgnoreCase));

        if (!alreadyConnected)
        {
            // Joindre le salon via SignalR
            await ChatService.JoinChannel(channel);
        }

        // Charger les donn√©es du salon
        isPrivateConversation = false;
        selectedPrivateUser = null;
        privateMessages.Clear();
        isSelectedUserOnline = false;

        currentChannel = channel;
        await LoadMessages();
        await LoadUsers();
        await LoadMyChannels();

        var channelInfo = channels.FirstOrDefault(c => c.Name.Equals(channel, StringComparison.OrdinalIgnoreCase));

        if (channelInfo == null)
        {
            muteNotification = $"Le salon #{channel} n'existe plus";
            currentChannel = null;
            currentChannelDescription = null;
            isCurrentChannelMuted = false;
            NavigateToRelativeIfNeeded("chat");
            StateHasChanged();
            return;
        }

        isCurrentChannelMuted = channelInfo.IsMuted;
        currentChannelDescription = channelInfo.Description;

        // Fermer la sidebar sur mobile
        sidebarOpen = false;

        // Ouvrir la liste des utilisateurs sur desktop, fermer sur mobile
        usersListOpen = !await DeviceDetector.IsMobileDeviceAsync();

        StateHasChanged();
    }

    private async Task LoadMyChannels()
    {
        try
        {
            // Charger UNIQUEMENT les salons sur lesquels l'utilisateur est connect√©
            var result = await Http.GetFromJsonAsync<List<Channel>>(
                $"/api/my-channels?username={Uri.EscapeDataString(currentUsername)}");

            if (result != null)
            {
                channels = result;
                Logger.LogInformation(
                    "Chargement des salons connect√©s pour {Username}: {ChannelCount} salons",
                    currentUsername,
                    channels.Count);
            }
            else
            {
                channels = new List<Channel>();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors du chargement des salons connect√©s pour {Username}", currentUsername);
            channels = new List<Channel>();
        }
    }

    private async Task LoadMessages()
    {
        try
        {
            var result = await Http.GetFromJsonAsync<List<Message>>($"/api/messages/{currentChannel}?userId={currentUserId}");
            if (result != null)
            {
                messages = [];
                foreach (var msg in result)
                {
                    if (IgnoredUsersService.IsUserIgnored(msg.UserId))
                    {
                        continue;
                    }
                    messages.Add(msg);
                }                
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors du chargement des messages pour le canal {Channel}", currentChannel);
        }
    }

    private async Task LoadUsers()
    {
        try
        {
            var result = await Http.GetFromJsonAsync<List<User>>($"/api/channels/{currentChannel}/users");
            if (result != null)
            {
                users = result;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors du chargement des users pour le canal {Channel}", currentChannel);
        }
    }

    private async Task SendMessage(string content)
    {
        var req = new SendMessageRequest
        {
            Content = content,
            Channel = currentChannel!
        };

        try
        {
            await ChatService.SendMessage(req);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors de l'envoi du message");
        }
    }

    private Task HandleUserClicked(User user)
    {
        if (user.Username != currentUsername)
        {
            NavigateToPrivateChatRoute(user);
        }

        return Task.CompletedTask;
    }

    private Task StartPrivateChat(User user)
    {
        NavigateToPrivateChatRoute(user);
        return Task.CompletedTask;
    }

    // M√©thodes pour messages priv√©s
    private async Task LoadPrivateConversations()
    {
        var conversations = await PrivateMessageService.GetConversationsAsync(currentUserId);
        privateConversations = [];
        foreach(var conversation in conversations)
        {
            if (IgnoredUsersService.IsUserIgnored(conversation.OtherUser!.UserId))
            {
                continue;
            }
            privateConversations.Add(conversation);
        }
    }

    private async Task OpenPrivateChatInternal(User user)
    {
        if (string.IsNullOrEmpty(user.UserId))
        {
            return;
        }

        isPrivateConversation = true;
        selectedPrivateUser = user;
        currentChannelDescription = null;

        await LoadPrivateMessages(user.UserId);

        await ChatService.MarkPrivateMessagesAsRead(user.UserId);
        await LoadPrivateConversations();

        // Charger le statut de connexion de l'utilisateur
        await UpdateSelectedUserStatus(user.Username);

        sidebarOpen = false;
        usersListOpen = false;
        StateHasChanged();
    }

    private async Task LoadPrivateMessages(string userId)
    {
        if (IgnoredUsersService.IsUserIgnored(userId))
        {
            privateMessages = [
              new PrivateMessage
              {
                Content = "Vous ignorez cet utilisiteur",
                SenderUsername = "üö´"
              }
            ];
        }
        else
        {
            privateMessages = await PrivateMessageService.GetPrivateMessagesAsync(currentUserId, userId);
        }
    }

    private async Task UpdateSelectedUserStatus(string username)
    {
        try
        {
            var response = await Http.GetFromJsonAsync<UserStatusResponse>($"/api/private-messages/status/{username}");
            if (response != null)
            {
                isSelectedUserOnline = response.IsOnline;
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Erreur lors de la r√©cup√©ration du statut de {Username}", username);
            isSelectedUserOnline = false;
        }
    }

    private void ClosePrivateChat()
    {
        var wasPrivate = isPrivateConversation;
        ClosePrivateChatState();

        if (wasPrivate)
        {
            NavigateToCurrentChannelOrHome();
        }
    }

    private void ClosePrivateChatState()
    {
        if (!isPrivateConversation)
        {
            return;
        }

        isPrivateConversation = false;
        selectedPrivateUser = null;
        privateMessages.Clear();
        isSelectedUserOnline = false;
        currentChannelDescription = null;
        StateHasChanged();
    }

    private async Task SendPrivateMessage(string content)
    {
        if (string.IsNullOrEmpty(selectedPrivateUser?.UserId) || !IsConnected)
        {
            return;
        }

        var request = new SendPrivateMessageRequest
        {
            RecipientUserId = selectedPrivateUser.UserId,
            RecipientUsername = selectedPrivateUser.Username,
            Content = content
        };

        try
        {
            await ChatService.SendPrivateMessage(request);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors de l'envoi du message priv√© √† {Recipient}", selectedPrivateUser);
        }
    }

    private async Task DeleteConversation(User otherUser)
    {
        var success = await PrivateMessageService.DeleteConversationAsync(currentUserId, otherUser.UserId);

        if (success)
        {
            if (selectedPrivateUser == otherUser && isPrivateConversation)
            {
                ClosePrivateChat();
            }

            await LoadPrivateConversations();
            StateHasChanged();
        }
    }

    private async Task HandleMuteStatusChanged(bool isMuted)
    {
        isCurrentChannelMuted = isMuted;
        await LoadMyChannels();
        StateHasChanged();
    }

    private bool CanManageCurrentChannel()
    {
        if (string.IsNullOrEmpty(currentChannel) || isPrivateConversation)
        {
            return false;
        }

        var channel = channels.FirstOrDefault(c => c.Name == currentChannel);
        if (channel == null) return false;

        bool isCreator = channel.CreatedBy.Equals(currentUsername, StringComparison.OrdinalIgnoreCase);
        bool isAdmin = Auth.IsAdmin;

        return isCreator || isAdmin;
    }

    private void HandleSidebarToggle(bool newState)
    {
        sidebarOpen = newState;
        StateHasChanged();
    }

    private void HandleUsersListToggle(bool newState)
    {
        usersListOpen = newState;
        StateHasChanged();
    }

    private async Task HandleChannelUpdated()
    {
        await LoadMyChannels();

        // Mettre √† jour la description du canal actuel
        if (!string.IsNullOrEmpty(currentChannel) && !isPrivateConversation)
        {
            var channelInfo = channels.FirstOrDefault(c =>
                c.Name.Equals(currentChannel, StringComparison.OrdinalIgnoreCase));
            if (channelInfo != null)
            {
                currentChannelDescription = channelInfo.Description;
            }
        }

        StateHasChanged();
    }

    private string? GetCurrentChannelOrUsername()
    {
        return isPrivateConversation ? selectedPrivateUser?.Username ?? "" : currentChannel;
    }

    private List<Message> GetCurrentMessages()
    {
        if (isPrivateConversation)
        {
            // Convertir les PrivateMessage en Message pour l'affichage
            return privateMessages.Select(pm => new Message
            {
                Id = pm.Id,
                Username = pm.SenderUsername,
                Content = pm.Content,
                Timestamp = pm.Timestamp
            }).ToList();
        }
        return messages;
    }

    private void NavigateToChannelRoute(string channel)
    {
        if (string.IsNullOrWhiteSpace(channel))
        {
            return;
        }

        var encodedChannel = Uri.EscapeDataString(channel);
        ChannelName = channel;
        PrivateUserId = null;
        PrivateUsername = null;
        NavigateToRelativeIfNeeded($"chat/channel/{encodedChannel}");
        _ = InvokeAsync(ApplyRouteStateAsync);
    }

    private void NavigateToPrivateChatRoute(User user)
    {
        if (user == null || string.IsNullOrEmpty(user.UserId))
        {
            return;
        }

        var encodedUserId = Uri.EscapeDataString(user.UserId);
        var usernameSegment = !string.IsNullOrEmpty(user.Username)
            ? $"/{Uri.EscapeDataString(user.Username)}"
            : string.Empty;

        ChannelName = null;
        currentChannel = null;
        currentChannelDescription = null;
        PrivateUserId = user.UserId;
        PrivateUsername = user.Username;
        NavigateToRelativeIfNeeded($"chat/private/{encodedUserId}{usernameSegment}");
        _ = InvokeAsync(ApplyRouteStateAsync);
    }

    private void NavigateToCurrentChannelOrHome()
    {
        if (!string.IsNullOrEmpty(currentChannel))
        {
            NavigateToChannelRoute(currentChannel);
        }
        else
        {
            NavigateToRelativeIfNeeded("chat");
        }
    }

    private void NavigateToRelativeIfNeeded(string relativePath)
    {
        var cleanedTarget = relativePath.TrimStart('/');
        var currentPath = Navigation.ToBaseRelativePath(Navigation.Uri).TrimStart('/');

        if (string.Equals(currentPath, cleanedTarget, StringComparison.Ordinal))
        {
            return;
        }

        Navigation.NavigateToRelative(cleanedTarget);
    }

    private User ResolveUserFromRoute(string userId, string? username)
    {
        var user = selectedPrivateUser?.UserId == userId
            ? selectedPrivateUser
            : privateConversations.FirstOrDefault(c => c.OtherUser?.UserId == userId)?.OtherUser
              ?? users.FirstOrDefault(u => u.UserId == userId);

        if (user == null)
        {
            user = new User
            {
                UserId = userId,
                Username = !string.IsNullOrEmpty(username) ? username : userId
            };
        }
        else if (!string.IsNullOrEmpty(username))
        {
            user.Username = username;
        }

        return user;
    }

    private string GetChatAreaKey()
    {
        if (isPrivateConversation && selectedPrivateUser != null)
        {
            return $"private-{selectedPrivateUser.UserId}";
        }

        if (!string.IsNullOrEmpty(currentChannel))
        {
            return $"channel-{currentChannel}";
        }

        return "chat-area-default";
    }

    public ValueTask DisposeAsync()
    {
        ChatService.OnMessageReceived -= OnMessageReceived;
        ChatService.OnUserJoined -= OnUserJoined;
        ChatService.OnUserLeft -= OnUserLeft;
        ChatService.OnChannelMuteStatusChanged -= OnChannelMuteStatusChanged;
        ChatService.OnMessageBlocked -= OnMessageBlocked;
        ChatService.OnChannelDeleted -= OnChannelDeleted;
        ChatService.OnChannelNotFound -= OnChannelNotFound;
        ChatService.OnChannelListUpdated -= OnChannelListUpdated;
        ChatService.OnUserStatusChanged -= OnUserStatusChanged;
        ChatService.OnUserMuted -= OnUserMutedSignalR;
        ChatService.OnUserUnmuted -= OnUserUnmutedSignalR;

        // √âv√©nements de connexion
        ChatService.OnDisconnected -= OnSignalRDisconnected;
        ChatService.OnReconnecting -= OnSignalRReconnecting;
        ChatService.OnReconnected -= OnSignalRReconnected;

        PrivateMessageService.OnPrivateMessageReceived -= OnPrivateMessageReceived;
        PrivateMessageService.OnPrivateMessageSent -= OnPrivateMessageSent;
        PrivateMessageService.OnUnreadCountChanged -= OnUnreadCountChanged;
        PrivateMessageService.OnConversationDeleted -= OnConversationDeleted;

        IgnoredUsersService.OnIgnoredUsersChanged -= OnIgnoredUsersChanged;

        GC.SuppressFinalize(this);

        return ValueTask.CompletedTask;
    }

    private sealed class UserStatusResponse
    {
        public string Username { get; set; } = string.Empty;
        [SuppressMessage("Major Code Smell", "S1144:Unused private types or members should be removed", Justification = "Deserialized")]
        public bool IsOnline { get; set; }
    }

    private enum ConnectionNotificationType
    {
        None,
        Disconnected,
        Reconnecting,
        Reconnected
    }
}
