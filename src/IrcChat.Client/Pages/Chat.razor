@* src/IrcChat.Client/Pages/Chat.razor *@
@page "/chat"
@using IrcChat.Client.Extensions
@using IrcChat.Client.Models
@using IrcChat.Shared.Models
@using IrcChat.Client.Services
@using IrcChat.Client.Components
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Extensions.Options
@using System.Net.Http.Headers
@using System.Diagnostics.CodeAnalysis
@inject HttpClient Http
@inject IChatService ChatService
@inject IUnifiedAuthService Auth
@inject IPrivateMessageService PrivateMessageService
@inject NavigationManager Navigation
@inject IOptions<ApiSettings> ApiSettingsOptions
@inject ILogger<Chat> Logger
@inject IDeviceDetectorService DeviceDetector
@inject IIgnoredUsersService IgnoredUsersService
@implements IAsyncDisposable

<PageTitle>IRC Chat</PageTitle>

@if (!isInitialized)
{
    <div class="loading">
        <div class="spinner"></div>
        <p>Chargement...</p>
    </div>
}
else if (!Auth.HasUsername)
{
    <p>Redirection vers la page de connexion...</p>
}
else
{
    <SidebarToggleButton IsOpen="sidebarOpen"
                         UnreadCount="totalUnreadCount"
                         OnToggle="HandleSidebarToggle" />

    <div class="chat-container @(sidebarOpen ? "sidebar-open" : "sidebar-closed")">
        <Sidebar IsOpen="sidebarOpen"
                 Username="@currentUsername"
                 AvatarUrl="@avatarUrl"
                 IsOAuthUser="@Auth.IsReserved"
                 IsAdmin="@Auth.IsAdmin"
                 CurrentChannel="@currentChannel"
                 Channels="@channels"
                 Users="@users"
                 PrivateConversations="@privateConversations"
                 SelectedPrivateUser="@selectedPrivateUser"
                 OnChannelSelected="SwitchChannel"
                 OnUserClicked="OpenPrivateChat"
                 OnPrivateConversationSelected="OpenPrivateChat"
                 OnConversationDeleted="DeleteConversation"
                 OnUserInfoClicked="GoToSettings"
                 OnChannelDeleted="HandleChannelDeleted" />

        <ChatArea Username="@currentUsername"
                  CurrentContactUserId="@selectedPrivateUser?.UserId"
                  CurrentChannel="@GetCurrentChannelOrUsername()"
                  IsConnected="@isConnected"
                  Messages="@GetCurrentMessages()"
                  Users="@(isPrivateConversation ? null : users)"
                  IsMuted="@isCurrentChannelMuted"
                  CanManage="@CanManageCurrentChannel()"
                  UsersListOpen="@usersListOpen"
                  IsPrivateConversation="@isPrivateConversation"
                  IsUserOnline="@isSelectedUserOnline"
                  OnMessageSent="@(isPrivateConversation ? SendPrivateMessage : SendMessage)"
                  OnUserClicked="HandleUserClicked"
                  OnMuteStatusChanged="HandleMuteStatusChanged"
                  OnClosePrivateConversation="ClosePrivateChat"
                  OnChannelDeleted="HandleChannelDeleted"
                  OnUsersListToggle="HandleUsersListToggle" />
    </div>

    @if (!string.IsNullOrEmpty(muteNotification))
    {
        <div class="mute-notification">
            @muteNotification
        </div>
    }
}

@code {
    private string currentChannel = "";
    private string currentUsername = "";
    private string currentUserId = "";
    private string? avatarUrl = null;
    private List<Message> messages = new();
    private List<Channel> channels = new();
    private List<User> users = new();
    private bool isConnected = false;
    private bool isInitialized = false;
    private bool isCurrentChannelMuted = false;
    private string muteNotification = "";
    private bool sidebarOpen = false;
    private bool usersListOpen = false;
    private int totalUnreadCount => privateConversations.Sum(c => c.UnreadCount);

    // Messages privÃ©s
    private List<PrivateConversation> privateConversations = new();
    private List<PrivateMessage> privateMessages = new();
    private User? selectedPrivateUser = null;
    private bool isPrivateConversation = false;
    private bool isSelectedUserOnline = false;

    protected override async Task OnInitializedAsync()
    {
        await Auth.InitializeAsync();
        await IgnoredUsersService.InitializeAsync();
        isInitialized = true;

        if (!Auth.HasUsername)
        {
            Navigation.NavigateToRelative("login");
            return;
        }

        currentUsername = Auth.Username!;
        currentUserId = await Auth.GetClientUserIdAsync();
        avatarUrl = Auth.AvatarUrl;

        // DÃ©terminer l'Ã©tat initial de la liste des utilisateurs selon la taille d'Ã©cran
        usersListOpen = !await DeviceDetector.IsMobileDeviceAsync();

        if (!string.IsNullOrEmpty(currentUsername))
        {
            if (Auth.IsAuthenticated && !string.IsNullOrEmpty(Auth.Token))
            {
                Http.DefaultRequestHeaders.Authorization =
                    new AuthenticationHeaderValue("Bearer", Auth.Token);
            }

            await InitializeSignalR();
            await LoadChannels();
            await LoadPrivateConversations();
        }
    }

    private async Task InitializeSignalR()
    {
        ChatService.OnMessageReceived += OnMessageReceived;
        ChatService.OnUserJoined += OnUserJoined;
        ChatService.OnUserLeft += OnUserLeft;
        ChatService.OnChannelDeleted += OnChannelDeleted;
        ChatService.OnChannelNotFound += OnChannelNotFound;
        ChatService.OnChannelListUpdated += OnChannelListUpdated;
        ChatService.OnUserStatusChanged += OnUserStatusChanged;

        PrivateMessageService.OnPrivateMessageReceived += OnPrivateMessageReceived;
        PrivateMessageService.OnPrivateMessageSent += OnPrivateMessageSent;
        PrivateMessageService.OnUnreadCountChanged += OnUnreadCountChanged;
        PrivateMessageService.OnConversationDeleted += OnConversationDeleted;

        IgnoredUsersService.OnIgnoredUsersChanged += OnIgnoredUsersChanged;

        if (ChatService.IsInitialized)
        {
            return;
        }

        try
        {
            var apiSettings = ApiSettingsOptions.Value;
            var hubUrl = !string.IsNullOrEmpty(apiSettings.SignalRHubUrl)
              ? apiSettings.SignalRHubUrl
              : $"{apiSettings.BaseUrl}/chathub";

            var hubConnectionBuilder = new HubConnectionBuilder()
                .WithUrl(hubUrl, options =>
                {
                    options.AccessTokenProvider = () => Task.FromResult(Auth.Token);
                })
                .WithAutomaticReconnect();
            await ChatService.InitializeAsync(hubConnectionBuilder);
            isConnected = true;

            ChatService.OnChannelMuteStatusChanged += OnChannelMuteStatusChanged;
            ChatService.OnMessageBlocked += OnMessageBlocked;

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors de l'initialisation de SignalR");
            isConnected = false;
        }
    }

    // Handlers pour canaux publics
    private void OnMessageReceived(Message message)
    {
        InvokeAsync(async () =>
        {
            if (message.Channel == currentChannel &&
              !isPrivateConversation &&
              !IgnoredUsersService.IsUserIgnored(message.UserId))
            {
                messages.Add(message);
                StateHasChanged();
            }
        });
    }

    private void OnUserJoined(string user, string userId, string channel)
    {
        if (channel == currentChannel && !isPrivateConversation && !users.Any(u => u.Username == user))
        {
            users.Add(new User { Username = user, UserId = userId });
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnUserLeft(string user, string userId, string channel)
    {
        if (channel == currentChannel && !isPrivateConversation)
        {
            users = users.Where(u => u.UserId != userId).ToList();
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnChannelMuteStatusChanged(string channel, bool isMuted)
    {        
        if (channel == currentChannel && !isPrivateConversation)
        {
            isCurrentChannelMuted = isMuted;
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnMessageBlocked(string reason)
    {
        muteNotification = reason;
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await Task.Delay(4000);
            muteNotification = "";
            StateHasChanged();
        });
    }

    private async void OnChannelDeleted(string channelName)
    {
        channels = channels.Where(c => c.Name != channelName).ToList();

        if (currentChannel == channelName && !isPrivateConversation)
        {
            currentChannel = "";
            messages.Clear();
        }

        await InvokeAsync(StateHasChanged);
    }

    private void OnChannelNotFound(string channelName)
    {
        muteNotification = $"Le canal #{channelName} n'existe plus";
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await Task.Delay(4000);
            muteNotification = "";
            StateHasChanged();
        });
    }

    private async void OnChannelListUpdated()
    {
        await LoadChannels();
        await InvokeAsync(StateHasChanged);
    }

    private async void OnUserStatusChanged(string username, bool isOnline)
    {
        // Mettre Ã  jour le statut dans les conversations
        var conversation = privateConversations.FirstOrDefault(c => c.OtherUser?.Username == username);
        if (conversation != null)
        {
            conversation.IsOnline = isOnline;
        }

        // Mettre Ã  jour le statut de l'utilisateur sÃ©lectionnÃ©
        if (isPrivateConversation && selectedPrivateUser?.Username == username)
        {
            isSelectedUserOnline = isOnline;
        }

        await InvokeAsync(StateHasChanged);
    }

    private Task HandleChannelDeleted(string channelName)
    {
        OnChannelDeleted(channelName);
        return Task.CompletedTask;
    }

    // Handlers pour messages privÃ©s
    private void OnPrivateMessageReceived(PrivateMessage message)
    {
        InvokeAsync(async () =>
        {
            if (isPrivateConversation &&
              (message.SenderUserId == selectedPrivateUser?.UserId || message.RecipientUserId == selectedPrivateUser?.UserId) &&
              !(IgnoredUsersService.IsUserIgnored(message.SenderUserId)))
            {
                privateMessages.Add(message);

                if (message.SenderUserId == selectedPrivateUser?.UserId)
                {
                    _ = ChatService.MarkPrivateMessagesAsRead(selectedPrivateUser!.UserId);
                }
            }

            await LoadPrivateConversations();
            StateHasChanged();
        });
    }

    private void OnPrivateMessageSent(PrivateMessage message)
    {
        if (isPrivateConversation && message.RecipientUserId == selectedPrivateUser?.UserId)
        {
            privateMessages.Add(message);
        }

        InvokeAsync(async () =>
        {
            await LoadPrivateConversations();
            StateHasChanged();
        });
    }

    private void OnUnreadCountChanged()
    {
        InvokeAsync(async () =>
        {
            await LoadPrivateConversations();
            StateHasChanged();
        });
    }

    private void OnConversationDeleted(string username)
    {
        if (selectedPrivateUser?.UserId == username && isPrivateConversation)
        {
            ClosePrivateChat();
        }

        InvokeAsync(async () =>
        {
            await LoadPrivateConversations();
            StateHasChanged();
        });
    }

    private void OnIgnoredUsersChanged()
    {
        InvokeAsync(async () =>
        {
            // Recharger les messages privÃ©s si une conversation est ouverte
            if (isPrivateConversation && selectedPrivateUser != null)
            {
                await OpenPrivateChat(selectedPrivateUser);
                StateHasChanged();
            }
        });
    }

    // Actions
    private void GoToSettings()
    {
        Navigation.NavigateToRelative("settings");
    }

    private async Task SwitchChannel(string channel)
    {
        if (channel != currentChannel)
        {
            await ChatService.LeaveChannel(currentChannel);
        }

        isPrivateConversation = false;
        selectedPrivateUser = null;
        privateMessages.Clear();
        isSelectedUserOnline = false;

        if (channel != currentChannel)
        {
            currentChannel = channel;
            await ChatService.JoinChannel(channel);
        }

        await LoadMessages();
        await LoadUsers();
        await LoadChannels();

        var channelInfo = channels.FirstOrDefault(c => c.Name == channel);
        isCurrentChannelMuted = channelInfo?.IsMuted ?? false;

        // Fermer la sidebar sur mobile
        sidebarOpen = false;

        // Ouvrir la liste des utilisateurs sur desktop, fermer sur mobile
        usersListOpen = !await DeviceDetector.IsMobileDeviceAsync();

        StateHasChanged();
    }

    private async Task LoadChannels()
    {
        try
        {
            var result = await Http.GetFromJsonAsync<List<Channel>>("/api/channels");
            if (result != null)
            {
                channels = result;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors du chargement des canaux");
        }
    }

    private async Task LoadMessages()
    {
        try
        {
            var result = await Http.GetFromJsonAsync<List<Message>>($"/api/messages/{currentChannel}?userId={Auth.UserId}");
            if (result != null)
            {
                messages = [];
                foreach (var msg in result)
                {
                    if (IgnoredUsersService.IsUserIgnored(msg.UserId))
                    {
                        continue;
                    }
                    messages.Add(msg);
                }                
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors du chargement des messages pour le canal {Channel}", currentChannel);
        }
    }

    private async Task LoadUsers()
    {
        try
        {
            var result = await Http.GetFromJsonAsync<List<User>>($"/api/channels/{currentChannel}/users");
            if (result != null)
            {
                users = result;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors du chargement des users pour le canal {Channel}", currentChannel);
        }
    }

    private async Task SendMessage(string content)
    {
        var req = new SendMessageRequest
        {
            Content = content,
            Channel = currentChannel
        };

        try
        {
            await ChatService.SendMessage(req);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors de l'envoi du message");
        }
    }

    private async Task HandleUserClicked(User user)
    {
        if (user.Username != currentUsername)
        {
            await OpenPrivateChat(user);
        }
    }

    // MÃ©thodes pour messages privÃ©s
    private async Task LoadPrivateConversations()
    {
        var conversations = await PrivateMessageService.GetConversationsAsync(currentUserId);
        privateConversations = [];
        foreach(var conversation in conversations)
        {
            if (IgnoredUsersService.IsUserIgnored(conversation.OtherUser!.UserId))
            {
                continue;
            }
            privateConversations.Add(conversation);
        }
    }

    private async Task OpenPrivateChat(User user)
    {
        isPrivateConversation = true;
        selectedPrivateUser = user;

        if (IgnoredUsersService.IsUserIgnored(user.UserId))
        {
            privateMessages = [
              new PrivateMessage
              {
                Content = "Vous ignorez cet utilisiteur",
                SenderUsername = "ðŸš«"
              }
            ];
        }
        else
        {
            privateMessages = await PrivateMessageService.GetPrivateMessagesAsync(currentUserId, user.UserId);
        }
        
        await ChatService.MarkPrivateMessagesAsRead(user.UserId);
        await LoadPrivateConversations();

        // Charger le statut de connexion de l'utilisateur
        await UpdateSelectedUserStatus(user.Username);

        sidebarOpen = false;
        usersListOpen = false;
        StateHasChanged();
    }

    private async Task UpdateSelectedUserStatus(string username)
    {
        try
        {
            var response = await Http.GetFromJsonAsync<UserStatusResponse>($"/api/private-messages/status/{username}");
            if (response != null)
            {
                isSelectedUserOnline = response.IsOnline;
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Erreur lors de la rÃ©cupÃ©ration du statut de {Username}", username);
            isSelectedUserOnline = false;
        }
    }

    private void ClosePrivateChat()
    {
        isPrivateConversation = false;
        selectedPrivateUser = null;
        privateMessages.Clear();
        isSelectedUserOnline = false;
        StateHasChanged();
    }

    private async Task SendPrivateMessage(string content)
    {
        if (string.IsNullOrEmpty(selectedPrivateUser?.UserId) || !isConnected)
        {
            return;
        }

        var request = new SendPrivateMessageRequest
        {
            RecipientUserId = selectedPrivateUser.UserId,
            RecipientUsername = selectedPrivateUser.Username,
            Content = content
        };

        try
        {
            await ChatService.SendPrivateMessage(request);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erreur lors de l'envoi du message privÃ© Ã  {Recipient}", selectedPrivateUser);
        }
    }

    private async Task DeleteConversation(User otherUser)
    {
        var success = await PrivateMessageService.DeleteConversationAsync(currentUserId, otherUser.UserId);

        if (success)
        {
            if (selectedPrivateUser == otherUser && isPrivateConversation)
            {
                ClosePrivateChat();
            }

            await LoadPrivateConversations();
            StateHasChanged();
        }
    }

    private async Task HandleMuteStatusChanged(bool isMuted)
    {
        isCurrentChannelMuted = isMuted;
        await LoadChannels();
        StateHasChanged();
    }

    private bool CanManageCurrentChannel()
    {
        if (string.IsNullOrEmpty(currentChannel) || isPrivateConversation)
        {
            return false;
        }

        var channel = channels.FirstOrDefault(c => c.Name == currentChannel);
        if (channel == null) return false;

        bool isCreator = channel.CreatedBy.Equals(currentUsername, StringComparison.OrdinalIgnoreCase);
        bool isAdmin = Auth.IsAdmin;

        return isCreator || isAdmin;
    }

    private void HandleSidebarToggle(bool newState)
    {
        sidebarOpen = newState;
        StateHasChanged();
    }

    private void HandleUsersListToggle(bool newState)
    {
        usersListOpen = newState;
        StateHasChanged();
    }

    private string GetCurrentChannelOrUsername()
    {
        return isPrivateConversation ? selectedPrivateUser?.Username ?? "" : currentChannel;
    }

    private List<Message> GetCurrentMessages()
    {
        if (isPrivateConversation)
        {
            // Convertir les PrivateMessage en Message pour l'affichage
            return privateMessages.Select(pm => new Message
            {
                Id = pm.Id,
                Username = pm.SenderUsername,
                Content = pm.Content,
                Timestamp = pm.Timestamp
            }).ToList();
        }
        return messages;
    }

    public async ValueTask DisposeAsync()
    {
        ChatService.OnMessageReceived -= OnMessageReceived;
        ChatService.OnUserJoined -= OnUserJoined;
        ChatService.OnUserLeft -= OnUserLeft;
        ChatService.OnChannelMuteStatusChanged -= OnChannelMuteStatusChanged;
        ChatService.OnMessageBlocked -= OnMessageBlocked;
        ChatService.OnChannelDeleted -= OnChannelDeleted;
        ChatService.OnChannelNotFound -= OnChannelNotFound;
        ChatService.OnChannelListUpdated -= OnChannelListUpdated;
        ChatService.OnUserStatusChanged -= OnUserStatusChanged;

        PrivateMessageService.OnPrivateMessageReceived -= OnPrivateMessageReceived;
        PrivateMessageService.OnPrivateMessageSent -= OnPrivateMessageSent;
        PrivateMessageService.OnUnreadCountChanged -= OnUnreadCountChanged;
        PrivateMessageService.OnConversationDeleted -= OnConversationDeleted;

        IgnoredUsersService.OnIgnoredUsersChanged -= OnIgnoredUsersChanged;

        GC.SuppressFinalize(this);
    }


    private sealed class UserStatusResponse
    {
        public string Username { get; set; } = string.Empty;
        [SuppressMessage("Major Code Smell", "S1144:Unused private types or members should be removed", Justification = "Deserialized")]
        public bool IsOnline { get; set; }
    }
}
